<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Photo Sorter & GIF Maker</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        background-color: #0d0d0d;
        color: #33ff00;
        font-family: "Courier New", Courier, monospace;
        overflow: hidden;
      }
      .terminal-cursor {
        animation: blink 1s step-end infinite;
      }
      @keyframes blink {
        50% {
          opacity: 0;
        }
      }

      /* App Styles Override for GUI Mode */
      .gui-mode {
        font-family: sans-serif;
        color: white;
      }
      .gui-mode body {
        background-color: #1a1a1a;
      }

      .loading-spinner {
        border-top-color: #3498db;
        animation: spinner 1.5s linear infinite;
      }
      @keyframes spinner {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      .custom-scroll::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      .custom-scroll::-webkit-scrollbar-track {
        background: #111;
      }
      .custom-scroll::-webkit-scrollbar-thumb {
        background: #555;
        border-radius: 4px;
      }

      input[type="range"] {
        -webkit-appearance: none;
        background: transparent;
        pointer-events: none;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        height: 16px;
        width: 16px;
        border-radius: 50%;
        background: #3b82f6;
        cursor: pointer;
        pointer-events: auto;
        margin-top: -6px;
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
      }
      input[type="range"]::-webkit-slider-runnable-track {
        width: 100%;
        height: 4px;
        cursor: pointer;
        background: transparent;
      }

      .crop-selection {
        border: 2px dashed #3498db;
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
      }
    </style>
  </head>
  <body>
    <div id="root" class="h-screen w-screen"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      // --- TERMINAL COMPONENT ---
      function Terminal({ onStart }) {
        const [history, setHistory] = useState([
          { type: "output", text: "Photo Sorter CLI v1.0" },
          {
            type: "output",
            text: 'Type "ls" to view files, "cd <folder>" to move.',
          },
          {
            type: "output",
            text: 'Type "start" or "select" to begin sorting the current folder.',
          },
        ]);
        const [input, setInput] = useState("");
        const [currentPath, setCurrentPath] = useState("");
        const [dirData, setDirData] = useState({
          folders: [],
          files: [],
          parent: null,
        });
        const endRef = useRef(null);
        const inputRef = useRef(null);

        const fetchDir = async (path) => {
          try {
            const res = await fetch("/api/browse", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ path }),
            });
            const data = await res.json();
            if (data.error) {
              setHistory((h) => [...h, { type: "error", text: data.error }]);
            } else {
              setCurrentPath(data.current_path);
              setDirData(data);
            }
          } catch (e) {
            setHistory((h) => [
              ...h,
              { type: "error", text: "Connection Error" },
            ]);
          }
        };

        useEffect(() => {
          fetchDir(null);
        }, []);
        useEffect(() => {
          endRef.current?.scrollIntoView({ behavior: "smooth" });
        }, [history]);
        useEffect(() => {
          inputRef.current?.focus();
        }, []);

        const handleCommand = async (e) => {
          if (e.key !== "Enter") return;
          const cmdLine = input.trim();
          setHistory((h) => [
            ...h,
            { type: "command", text: cmdLine, path: currentPath },
          ]);
          setInput("");
          if (!cmdLine) return;

          const parts = cmdLine.split(" ");
          const cmd = parts[0].toLowerCase();
          const args = parts.slice(1).join(" ");

          if (cmd === "ls" || cmd === "ll") {
            const folderList = dirData.folders
              .map((f) => `[DIR]  ${f}`)
              .join("\n");
            const fileList = dirData.files.map((f) => `       ${f}`).join("\n");
            const output =
              (folderList ? folderList + "\n" : "") +
              (fileList || (folderList ? "" : "(empty)"));
            setHistory((h) => [...h, { type: "output", text: output }]);
          } else if (cmd === "cd") {
            if (!args) return;
            if (args === "..") {
              if (dirData.parent) await fetchDir(dirData.parent);
              else
                setHistory((h) => [
                  ...h,
                  { type: "error", text: "Already at root" },
                ]);
            } else {
              let target = args;
              if (!args.startsWith("/") && !args.includes(":")) {
                const sep = dirData.sep || "/";
                target = currentPath.endsWith(sep)
                  ? currentPath + args
                  : currentPath + sep + args;
              }
              await fetchDir(target);
            }
          } else if (
            cmd === "start" ||
            cmd === "select" ||
            cmd === "open" ||
            cmd === "."
          ) {
            onStart(currentPath);
          } else if (cmd === "clear") setHistory([]);
          else if (cmd === "pwd")
            setHistory((h) => [...h, { type: "output", text: currentPath }]);
          else
            setHistory((h) => [
              ...h,
              { type: "error", text: `Command not found: ${cmd}` },
            ]);
        };

        return (
          <div
            className="h-full w-full bg-black p-4 font-mono text-sm md:text-base overflow-y-auto"
            onClick={() => inputRef.current?.focus()}
          >
            {history.map((line, i) => (
              <div key={i} className="mb-1 whitespace-pre-wrap break-words">
                {line.type === "command" ? (
                  <span className="text-gray-400">
                    user@photo-sorter:
                    <span className="text-blue-400">{line.path}</span> ${" "}
                    <span className="text-white">{line.text}</span>
                  </span>
                ) : line.type === "error" ? (
                  <span className="text-red-500">{line.text}</span>
                ) : (
                  <span className="text-[#33ff00]">{line.text}</span>
                )}
              </div>
            ))}
            <div className="flex items-center text-gray-400 mt-2">
              <span className="mr-2">
                user@photo-sorter:
                <span className="text-blue-400">{currentPath}</span> $
              </span>
              <input
                ref={inputRef}
                type="text"
                className="bg-transparent border-none outline-none text-white flex-1"
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={handleCommand}
                autoComplete="off"
                autoFocus
              />
            </div>
            <div ref={endRef} className="h-4" />
          </div>
        );
      }

      // --- MAIN APP COMPONENT ---
      function App() {
        const [mode, setMode] = useState("terminal");
        const [path, setPath] = useState("");
        const [groups, setGroups] = useState([]);
        const [currentIndex, setCurrentIndex] = useState(0);
        const [loading, setLoading] = useState(false);

        // GUI State
        const [gifPreviewUrl, setGifPreviewUrl] = useState(null);
        const [gifMode, setGifMode] = useState("normal");
        const [viewMode, setViewMode] = useState("image");
        const [processing, setProcessing] = useState(false);
        const [filesToTrash, setFilesToTrash] = useState(new Set());
        const [showNameModal, setShowNameModal] = useState(false);
        const [placeNameInput, setPlaceNameInput] = useState("");
        const [includedInGif, setIncludedInGif] = useState(new Set());

        // Image/Video Editing State
        const [rotation, setRotation] = useState(0);
        const [videoDuration, setVideoDuration] = useState(0);
        const [trimStart, setTrimStart] = useState(0);
        const [trimEnd, setTrimEnd] = useState(0);
        const [isCropping, setIsCropping] = useState(false);
        const [cropStart, setCropStart] = useState(null);
        const [cropRect, setCropRect] = useState(null);

        const cardRef = useRef(null);
        const videoRef = useRef(null);
        const imageContainerRef = useRef(null);

        useEffect(() => {
          if (mode === "gui") {
            document.body.classList.add("gui-mode");
            document.body.style.backgroundColor = "#1a1a1a";
            document.body.style.color = "white";
          } else {
            document.body.classList.remove("gui-mode");
            document.body.style.backgroundColor = "#0d0d0d";
            document.body.style.color = "#33ff00";
          }
        }, [mode]);

        const startScanning = async (selectedPath) => {
          setPath(selectedPath);
          setMode("gui");
          setLoading(true);
          try {
            const res = await fetch("/api/scan", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ path: selectedPath }),
            });
            const data = await res.json();
            if (data.groups && data.groups.length > 0) {
              setGroups(data.groups);
              setCurrentIndex(0);
              setViewMode("image");
            } else {
              alert("Folder is empty or contains no supported images.");
              setMode("terminal");
            }
          } catch (e) {
            alert("Connection error during scan.");
            setMode("terminal");
          }
          setLoading(false);
        };

        const currentGroup = groups[currentIndex];
        const nextGroup =
          currentIndex + 1 < groups.length ? groups[currentIndex + 1] : null;

        const isBurst = currentGroup?.count > 1;
        const isVideo = currentGroup?.type === "video";
        const isGif = currentGroup?.type === "gif";

        useEffect(() => {
          setRotation(0);
          setTrimStart(0);
          setTrimEnd(0);
          setVideoDuration(0);
          setIsCropping(false);
          setCropRect(null);
          setGifPreviewUrl(null);
          if (groups[currentIndex]) {
            setIncludedInGif(
              new Set(groups[currentIndex].files.map((_, i) => i)),
            );
          }
        }, [currentIndex, groups]);

        const animateSwipe = (direction, callback) => {
          if (!cardRef.current) {
            callback();
            return;
          }
          const xMove = direction === "left" ? -500 : 500;
          const rot = direction === "left" ? -20 : 20;
          gsap.to(cardRef.current, {
            x: xMove,
            rotation: rot,
            opacity: 0,
            duration: 0.4,
            onComplete: () => {
              callback();
              if (cardRef.current)
                gsap.set(cardRef.current, { x: 0, rotation: 0, opacity: 1 });
            },
          });
        };

        const toggleGifFrame = (idx) => {
          const next = new Set(includedInGif);
          if (next.has(idx)) next.delete(idx);
          else next.add(idx);
          setIncludedInGif(next);
          if (viewMode === "gif_preview") setViewMode("image");
        };

        const performAction = async (action, options = {}) => {
          if (processing) return;

          if (action === "save_gif" && !options.placeConfirmed) {
            setShowNameModal(true);
            return;
          }

          setProcessing(true);
          const actionData = { action, groupId: currentGroup.id, ...options };

          if (action === "keep_all" && !isVideo && !isGif) {
            actionData.rotation = rotation;
            if (cropRect) actionData.crop = cropRect;
          }
          if (action === "keep_all" && isVideo) {
            actionData.rotation = rotation;
            actionData.trimStart = trimStart;
            actionData.trimEnd = trimEnd < videoDuration ? trimEnd : null;
          }
          if (action === "save_gif")
            actionData.includedIndices = Array.from(includedInGif);

          if (action === "save_gif") {
            try {
              await fetch("/api/action", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(actionData),
              });
              setViewMode("review_sources");
              setFilesToTrash(new Set());
              setShowNameModal(false);
            } catch (e) {
              alert("Failed to save GIF");
            }
            setProcessing(false);
            return;
          }

          const execute = async () => {
            try {
              await fetch("/api/action", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(actionData),
              });
              const newGroups = [...groups];
              newGroups.splice(currentIndex, 1);
              setGroups(newGroups);
              setViewMode("image");
              setPlaceNameInput("");
            } catch (e) {
              alert("Action Failed");
            }
            setProcessing(false);
          };

          const direction =
            action === "trash_all" ||
            (action === "batch_organize" && options.trashIndices?.length > 0)
              ? "left"
              : "right";
          animateSwipe(direction, execute);
        };

        const generatePreview = async (mode) => {
          if (includedInGif.size === 0) {
            alert("Select at least one frame.");
            return;
          }
          setGifMode(mode);
          setGifPreviewUrl(null);
          setViewMode("gif_preview");
          const res = await fetch("/api/generate_preview_gif", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              groupId: currentGroup.id,
              mode,
              duration: 150,
              includedIndices: Array.from(includedInGif),
            }),
          });
          const blob = await res.blob();
          setGifPreviewUrl(URL.createObjectURL(blob));
        };

        const handleRotate = () => setRotation((prev) => (prev + 90) % 360);
        const handleVideoMeta = (e) => {
          const dur = e.target.duration;
          setVideoDuration(dur);
          setTrimStart(0);
          setTrimEnd(dur);
        };
        const handleTrim = (type, val) => {
          const numVal = parseFloat(val);
          if (type === "start") {
            setTrimStart(Math.min(numVal, trimEnd - 0.5));
            if (videoRef.current) videoRef.current.currentTime = numVal;
          } else setTrimEnd(Math.max(numVal, trimStart + 0.5));
        };

        const startCrop = (e) => {
          if (!isCropping) return;
          const rect = imageContainerRef.current.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width;
          const y = (e.clientY - rect.top) / rect.height;
          setCropStart({ x, y });
          setCropRect({ x, y, w: 0, h: 0 });
        };
        const moveCrop = (e) => {
          if (!isCropping || !cropStart) return;
          const rect = imageContainerRef.current.getBoundingClientRect();
          const currentX = (e.clientX - rect.left) / rect.width;
          const currentY = (e.clientY - rect.top) / rect.height;
          const x = Math.min(cropStart.x, currentX);
          const y = Math.min(cropStart.y, currentY);
          const w = Math.abs(currentX - cropStart.x);
          const h = Math.abs(currentY - cropStart.y);
          setCropRect({ x, y, w, h });
        };
        const endCrop = () => setCropStart(null);
        const getRotationStyle = () => ({
          transform: `rotate(${rotation}deg) scale(${rotation % 180 !== 0 ? 0.7 : 1})`,
          transition: "transform 0.3s",
        });

        useEffect(() => {
          const handleKeyDown = (e) => {
            if (processing || loading || showNameModal || mode === "terminal")
              return;
            if (e.target.tagName === "INPUT") return;
            if (viewMode === "image") {
              if (e.key === "ArrowRight") performAction("keep_all");
              if (e.key === "ArrowLeft") performAction("trash_all");
            }
          };
          window.addEventListener("keydown", handleKeyDown);
          return () => window.removeEventListener("keydown", handleKeyDown);
        }, [groups, currentIndex, viewMode, processing, showNameModal, mode]);

        if (mode === "terminal") {
          return <Terminal onStart={startScanning} />;
        }

        if (!groups.length && !loading) {
          return (
            <div className="flex flex-col items-center justify-center h-screen space-y-4 bg-gray-900 text-white">
              <h1 className="text-3xl font-bold">Done!</h1>
              <button
                onClick={() => setMode("terminal")}
                className="text-blue-400 hover:underline"
              >
                Return to Terminal
              </button>
            </div>
          );
        }

        return (
          <div className="flex flex-col h-screen select-none">
            {/* Header */}
            <div className="h-14 bg-gray-900 flex items-center justify-between px-6 border-b border-gray-800 shrink-0">
              <div className="flex items-center gap-4">
                <span className="text-xl font-bold text-gray-200">
                  {currentIndex + 1}{" "}
                  <span className="text-gray-600">/ {groups.length}</span>
                </span>
                <span className="text-sm text-gray-500 font-mono hidden md:block truncate max-w-md">
                  {path}
                </span>
              </div>
              <div>
                <button
                  onClick={() => setMode("terminal")}
                  className="text-red-400 text-sm hover:text-red-300"
                >
                  Exit to Terminal
                </button>
              </div>
            </div>

            <div className="flex-1 flex items-center justify-center relative overflow-hidden bg-black">
              {loading ? (
                <div className="loading-spinner h-16 w-16 rounded-full border-4 border-gray-700"></div>
              ) : currentGroup ? (
                <div className="relative w-full max-w-5xl h-[85vh] flex flex-col items-center justify-center p-4">
                  {showNameModal && (
                    <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur">
                      <div className="bg-gray-800 p-8 rounded-xl shadow-2xl w-96 border border-gray-700 text-white">
                        <h3 className="text-xl font-bold mb-4">
                          Name this GIF
                        </h3>
                        <input
                          autoFocus
                          type="text"
                          placeholder="e.g. Kitchen_Dance"
                          className="w-full p-3 bg-gray-900 border border-gray-600 rounded mb-6 text-white outline-none focus:border-blue-500"
                          value={placeNameInput}
                          onChange={(e) => setPlaceNameInput(e.target.value)}
                          onKeyDown={(e) =>
                            e.key === "Enter" &&
                            performAction("save_gif", {
                              place: placeNameInput,
                              gifMode: gifMode,
                              placeConfirmed: true,
                            })
                          }
                        />
                        <div className="flex justify-end gap-3">
                          <button
                            onClick={() => setShowNameModal(false)}
                            className="px-4 py-2 text-gray-400 hover:text-white"
                          >
                            Cancel
                          </button>
                          <button
                            onClick={() =>
                              performAction("save_gif", {
                                place: placeNameInput,
                                gifMode: gifMode,
                                placeConfirmed: true,
                              })
                            }
                            className="px-6 py-2 bg-blue-600 rounded font-bold hover:bg-blue-500"
                          >
                            Save
                          </button>
                        </div>
                      </div>
                    </div>
                  )}

                  {/* Background Preview of Next Image - Stacked Effect */}
                  {nextGroup && viewMode !== "review_sources" && (
                    <div className="absolute inset-0 flex items-center justify-center z-0 pointer-events-none transform scale-100 rotate-6 opacity-40 translate-x-4">
                      <div className="w-full h-full max-w-5xl p-4 flex items-center justify-center">
                        <img
                          src={`/api/media?groupId=${nextGroup.id}&imgIndex=0&thumb=true`}
                          className="max-w-full max-h-full object-contain filter brightness-50"
                        />
                      </div>
                    </div>
                  )}

                  <div
                    ref={cardRef}
                    className="relative w-full h-full flex flex-col items-center justify-center z-10 bg-black/50 backdrop-blur-sm rounded-xl"
                  >
                    {processing && (
                      <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/60 rounded-xl backdrop-blur-sm">
                        <div className="loading-spinner h-12 w-12 rounded-full border-4 border-white mb-4"></div>
                        <div className="text-white font-bold animate-pulse">
                          Processing...
                        </div>
                      </div>
                    )}

                    {viewMode !== "review_sources" && (
                      <>
                        {isBurst && (
                          <div className="absolute top-0 transform -translate-y-full mb-2 bg-orange-600 text-white px-4 py-1 rounded-full text-sm font-bold shadow-lg">
                            BURST ({currentGroup.count})
                          </div>
                        )}

                        <div className="relative w-full flex-1 min-h-0 flex flex-col items-center justify-center bg-gray-900 border border-gray-800 rounded-xl overflow-hidden p-2">
                          {viewMode === "image" ? (
                            isVideo || isGif ? (
                              <div className="relative w-full h-full flex items-center justify-center overflow-hidden">
                                {isVideo && (
                                  <button
                                    onClick={handleRotate}
                                    className="absolute top-4 right-4 z-20 bg-gray-800/80 p-2 rounded text-xs border border-gray-600 text-white"
                                  >
                                    â†» Rotate
                                  </button>
                                )}
                                {isVideo ? (
                                  <video
                                    ref={videoRef}
                                    controls
                                    autoPlay
                                    loop
                                    muted
                                    playsInline
                                    src={`/api/media?groupId=${currentGroup.id}&imgIndex=0`}
                                    onLoadedMetadata={handleVideoMeta}
                                    className="max-h-full max-w-full object-contain"
                                    style={getRotationStyle()}
                                  />
                                ) : (
                                  <img
                                    src={`/api/media?groupId=${currentGroup.id}&imgIndex=0`}
                                    className="max-h-full max-w-full object-contain"
                                  />
                                )}
                              </div>
                            ) : (
                              <div className="relative w-full h-full flex items-center justify-center overflow-hidden group">
                                <div className="absolute top-4 right-4 z-20 flex gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                                  <button
                                    onClick={() => {
                                      setIsCropping(!isCropping);
                                      setCropRect(null);
                                    }}
                                    className={`p-2 rounded text-xs border shadow text-white ${isCropping ? "bg-blue-600 border-blue-400" : "bg-gray-800/80 border-gray-600"}`}
                                  >
                                    {isCropping ? "Cancel Crop" : "Crop"}
                                  </button>
                                  <button
                                    onClick={handleRotate}
                                    className="bg-gray-800/80 p-2 rounded text-xs border border-gray-600 shadow text-white"
                                  >
                                    â†» Rotate
                                  </button>
                                </div>
                                {/* FIXED: Vertical Image Container */}
                                <div
                                  ref={imageContainerRef}
                                  className={`relative w-full h-full flex items-center justify-center ${isCropping ? "cursor-crosshair" : ""}`}
                                  style={getRotationStyle()}
                                  onMouseDown={startCrop}
                                  onMouseMove={moveCrop}
                                  onMouseUp={endCrop}
                                >
                                  {/* FIXED: Ensure object-contain fills available space without cropping */}
                                  <img
                                    src={`/api/media?groupId=${currentGroup.id}&imgIndex=0&thumb=false`}
                                    className="max-w-full max-h-full object-contain pointer-events-none shadow-2xl"
                                  />
                                  {cropRect && (
                                    <div
                                      className="absolute crop-selection"
                                      style={{
                                        left: `${cropRect.x * 100}%`,
                                        top: `${cropRect.y * 100}%`,
                                        width: `${cropRect.w * 100}%`,
                                        height: `${cropRect.h * 100}%`,
                                      }}
                                    ></div>
                                  )}
                                </div>
                                {isCropping && (
                                  <div className="absolute bottom-4 bg-black/60 px-3 py-1 rounded text-xs text-white">
                                    Drag to crop. Rotate first if needed.
                                  </div>
                                )}
                              </div>
                            )
                          ) : (
                            <div className="flex flex-col items-center justify-center h-full w-full bg-gray-800">
                              {gifPreviewUrl ? (
                                <img
                                  src={gifPreviewUrl}
                                  className="object-contain h-full w-full"
                                />
                              ) : (
                                <div className="text-blue-400 animate-pulse">
                                  Generating GIF...
                                </div>
                              )}
                            </div>
                          )}
                        </div>

                        {isBurst && !isVideo && !isGif && (
                          <div className="w-full mt-2 px-4 py-2 bg-gray-900 border border-gray-800 rounded-lg">
                            <div className="flex gap-2 overflow-x-auto custom-scroll pb-2">
                              {currentGroup.files.map((file, idx) => (
                                <div
                                  key={idx}
                                  onClick={() => toggleGifFrame(idx)}
                                  className={`relative w-16 h-16 flex-shrink-0 cursor-pointer border-2 rounded overflow-hidden transition-all ${includedInGif.has(idx) ? "border-green-500 opacity-100 scale-100" : "border-gray-700 opacity-40 scale-95"}`}
                                >
                                  <img
                                    src={`/api/media?groupId=${currentGroup.id}&imgIndex=${idx}&thumb=true`}
                                    className="w-full h-full object-cover"
                                  />
                                </div>
                              ))}
                            </div>
                            <div className="text-center text-xs text-gray-500 mt-1">
                              Select frames for GIF
                            </div>
                          </div>
                        )}

                        {isVideo &&
                          videoDuration > 0 &&
                          viewMode === "image" && (
                            <div className="w-full mt-4 px-4 py-3 bg-gray-800 rounded-lg border border-gray-700">
                              <div className="flex justify-between text-xs text-gray-400 mb-2 font-mono">
                                <span>Start: {trimStart.toFixed(1)}s</span>
                                <span>End: {trimEnd.toFixed(1)}s</span>
                              </div>
                              <div className="relative h-6 w-full">
                                <div className="absolute top-1/2 left-0 w-full h-1 bg-gray-600 rounded transform -translate-y-1/2"></div>
                                <div
                                  className="absolute top-1/2 h-1 bg-blue-500 rounded transform -translate-y-1/2"
                                  style={{
                                    left: `${(trimStart / videoDuration) * 100}%`,
                                    right: `${100 - (trimEnd / videoDuration) * 100}%`,
                                  }}
                                ></div>
                                <input
                                  type="range"
                                  min="0"
                                  max={videoDuration}
                                  step="0.1"
                                  value={trimStart}
                                  onChange={(e) =>
                                    handleTrim("start", e.target.value)
                                  }
                                  className="absolute top-0 left-0 w-full z-10"
                                />
                                <input
                                  type="range"
                                  min="0"
                                  max={videoDuration}
                                  step="0.1"
                                  value={trimEnd}
                                  onChange={(e) =>
                                    handleTrim("end", e.target.value)
                                  }
                                  className="absolute top-0 left-0 w-full z-20"
                                />
                              </div>
                            </div>
                          )}

                        <div className="mt-6 flex gap-6 items-center">
                          {isBurst && !isVideo && !isGif ? (
                            <div className="flex flex-col items-center gap-4">
                              <div className="flex bg-gray-800 p-1 rounded-lg">
                                <button
                                  onClick={() => generatePreview("normal")}
                                  className={`px-4 py-2 rounded ${gifMode === "normal" && viewMode === "gif_preview" ? "bg-blue-600 text-white" : "text-gray-400"}`}
                                >
                                  Loop
                                </button>
                                <button
                                  onClick={() => generatePreview("bounce")}
                                  className={`px-4 py-2 rounded ${gifMode === "bounce" && viewMode === "gif_preview" ? "bg-purple-600 text-white" : "text-gray-400"}`}
                                >
                                  Bounce
                                </button>
                              </div>
                              {viewMode === "gif_preview" && gifPreviewUrl && (
                                <div className="flex gap-4">
                                  <button
                                    onClick={() =>
                                      performAction("save_gif", { gifMode })
                                    }
                                    className="bg-green-600 hover:bg-green-500 px-8 py-3 rounded-lg font-bold shadow-lg text-white"
                                  >
                                    Save GIF
                                  </button>
                                  <button
                                    onClick={() => performAction("trash_all")}
                                    className="bg-red-600/50 hover:bg-red-600 px-6 py-3 rounded-lg font-bold text-white"
                                  >
                                    Trash All
                                  </button>
                                </div>
                              )}
                              {viewMode === "image" && (
                                <div className="flex gap-4">
                                  <button
                                    onClick={() => performAction("keep_all")}
                                    className="bg-gray-700 hover:bg-gray-600 px-6 py-2 rounded-lg text-white"
                                  >
                                    Keep {cropRect ? "(Edited)" : ""}
                                  </button>
                                  <button
                                    onClick={() => performAction("trash_all")}
                                    className="bg-red-900/50 hover:bg-red-800 px-6 py-2 rounded-lg text-red-200"
                                  >
                                    Delete
                                  </button>
                                </div>
                              )}
                            </div>
                          ) : (
                            <>
                              <button
                                onClick={() => performAction("trash_all")}
                                className="bg-gray-800 hover:bg-red-900 border border-gray-700 hover:border-red-500 px-8 py-4 rounded-full text-xl transition flex items-center gap-2 group text-white"
                              >
                                <span className="group-hover:scale-125 transition">
                                  ðŸ—‘
                                </span>{" "}
                                Trash
                              </button>
                              <button
                                onClick={() => performAction("keep_all")}
                                className="bg-blue-600 hover:bg-blue-500 px-10 py-4 rounded-full text-xl font-bold shadow-blue-900/50 shadow-lg transition transform hover:scale-105 flex items-center gap-2 text-white"
                              >
                                Keep <span className="text-2xl">â†’</span>
                              </button>
                            </>
                          )}
                        </div>
                      </>
                    )}

                    {viewMode === "review_sources" && (
                      <div className="w-full h-full flex flex-col">
                        <div className="mb-4 flex justify-between items-center">
                          <h2 className="text-xl font-bold text-green-400">
                            GIF Saved! Review Original Photos:
                          </h2>
                          <button
                            onClick={() =>
                              performAction("batch_organize", {
                                trashIndices: Array.from(filesToTrash),
                              })
                            }
                            className="bg-blue-600 hover:bg-blue-500 px-6 py-2 rounded font-bold text-white"
                          >
                            Done
                          </button>
                        </div>
                        <div className="flex-1 overflow-y-auto custom-scroll p-4 bg-gray-900 rounded-lg grid grid-cols-5 gap-4">
                          {currentGroup.files.map((file, idx) => (
                            <div
                              key={idx}
                              onClick={() => {
                                const s = new Set(filesToTrash);
                                s.has(idx) ? s.delete(idx) : s.add(idx);
                                setFilesToTrash(s);
                              }}
                              className={`relative aspect-square cursor-pointer rounded border-4 ${filesToTrash.has(idx) ? "border-red-600 opacity-50" : "border-transparent"}`}
                            >
                              <img
                                src={`/api/media?groupId=${currentGroup.id}&imgIndex=${idx}`}
                                className="w-full h-full object-cover"
                              />
                              {filesToTrash.has(idx) && (
                                <div className="absolute inset-0 flex items-center justify-center bg-black/40">
                                  <span className="text-4xl">ðŸ—‘</span>
                                </div>
                              )}
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              ) : (
                <div className="text-2xl text-gray-500">Folder Empty</div>
              )}
            </div>
          </div>
        );
      }
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
